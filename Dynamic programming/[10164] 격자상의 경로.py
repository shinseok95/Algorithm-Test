"""
이번 문제는 동적계획법과 곱의 법칙을 활용하여 해결하였다.

맨 처음에는 곱의 법칙과 DFS를 통하여 해결하려고 하였다. 

내 계산대로라면 분기가 최대 2^16개이라서, 대략 6만개정도의 분기가 생기고 이정도면 충분히 1초 안에 커버 가능하다고 생각하였기 때문이다.

그러나 DFS를 사용할 경우, (15,15,0)의 경우 시간이 매우 오래 걸렸다.

왜그런지는 좀 더 찾아봐야할 것 같다.

그래서 동적계획법을 통해서 문제를 다시 접근하였고, 점화식은 비교적으로 간단하게 도출되었다.

DP[i][j] = DP[i][j-1]+dp[i-1][j] (i,j != 1)
DP[i][j] = 1 (i,j == 1)

우선 로봇이 움직일 수 있는 방향은 오른쪽과 아래쪽 뿐이니, 대각선을 가는 경우의 수는 오른쪽->아래쪽 / 아래쪽->오른쪽의 경우밖에 존재하지 않는다.
즉, i-1번째에서 오른쪽으로 이동한 경우의 수와 아래쪽으로 이동한 경우의 수를 더해주면 된다.

그리고 K까지의 경우의 수를 구했다면, 다시 K에서 N,M까지의 경우의 수를 구하고 곱해주면 된다. 왜냐하면 두 사건 모두 독립적인 사건이기 때문에 곱의 법칙이 적용되기 때문이다.

"""

import math
  
N,M,K = map(int,input().split())

if K == 0 :
  
  dp = [[0,1]+[0]*(M-1) if i != 1 else [1]*(M+1) for i in range(N+1)]

  for i in range(2,N+1):
    for j in range(2,M+1):
      
      dp[i][j] = dp[i-1][j]+dp[i][j-1]
  
  print(dp[N][M])

else:
  n1 = math.ceil(K/M)
  m1 = K%M

  if m1==0:
    m1=M

  n2 = N-n1+1
  m2 = M-m1+1

  dp_1 = [[0,1]+[0]*(m1-1) if i != 1 else [1]*(m1+1) for i in range(n1+1)]

  dp_2 = [[0,1]+[0]*(m2-1) if i != 1 else [1]*(m2+1) for i in range(n2+1)]

  for i in range(2,n1+1):
    for j in range(2,m1+1):
      
      dp_1[i][j] = dp_1[i-1][j]+dp_1[i][j-1]

  for i in range(2,n2+1):
    for j in range(2,m2+1):
      
      dp_2[i][j] = dp_2[i-1][j]+dp_2[i][j-1]
  
  print(dp_1[n1][m1]*dp_2[n2][m2])
