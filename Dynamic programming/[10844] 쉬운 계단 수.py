"""

생각보다 간단하게 풀린 DP 문제였다.

우선 '계단 수'란, 인접한 모든 자리수의 차이가 1이 나는 수를 말한다.

예를 들어, 1은 0,2 / 2는 1,3이 있다.

그렇다면 이 문제는 각 자리수가 정해질 때마다 경우의 수가 2배씩 많아지는 것을 알 수 있다.

예를 들어, N=3이면 2로 시작하는 자리수는 다음과 같을 것이다.

2->(1),(3)->(0,2),(2,4)

즉, 다음 자리수는 이전 자리수에 영향을 받게되고 점화식은 다음과 같다.

i : 자리수 / j : 자리수에 올 수 있는 수

DP[i][j] = DP[i-1][j-1]+DP[i-1][j+1] (1<=j<=9)

DP[i][j] = DP[i-1][j+1] (j==0)
DP[i][j] = DP[i-1][j-1] (j==9)

0과 9는 다음 계단수로 1과 8밖에 받지 못하기 때문에 위와 같은 제한을 줘야한다.

"""

mod = 1000000000
N = int(input())

dp = [[0]*11 if i != 1 else [1]*10+[0] for i in range(101)]

for i in range(2,101):
  for j in range(10):
    
    if j == 0:
      dp[i][j] = dp[i-1][j+1]%mod
    else:
      dp[i][j] = (dp[i-1][j-1] + dp[i-1][j+1])%mod

print(sum(dp[N][1:10])%mod) 