"""
정답에 거의 근접했는데 결국에 풀지는 못했다.

우선 기존의 1,2,3 더하기 문제에서는 연속하는 수가 올 수 없다는 조건이 없어서 다음과 같은 점화식으로 풀렸다.

P(N) = P(N-3) + P(N-2) + P(N-1)

그러나 이번에는 연속한 수는 올 수 없다는 조건이 붙어서 꽤나 까다로웠다.

많은 고민을 하다가, 결국 

P(N-3) 중 끝자리가 1,2인 수
P(N-2) 중 끝자리가 1,3인 수
P(N-1) 중 끝자리가 2,3인 수

의 합이라는 점화식까지는 도출 할 수 있었다.

그러나 계속 시간초과가 떠서 왜 그럴까 생각을 해봤는데, 두 가지 문제가 있었다.

첫 번쨰, 테스트케이스가 여러 개일 때의 DP 문제는 for문 밖에서 먼저 bottom up으로 배열을 완성시켜놓고 출력해야한다는 점이다.

두 번째, mod를 나눠줘야지 시간이 많이 안걸린다는 점이다. 만약 매번 mod를 나누지 않아준다면, 수가 너무 커져서 속도가 떨어지게 된다.


나중에 다시 풀어보자!
"""

mod = 1000000009

cache = [[0]*4 for _ in range(100001)]

cache[1][1] = 1
cache[2][2] = 1
cache[3][1] = 1
cache[3][2] = 1
cache[3][3] = 1

for i in range(4,100001):
  cache[i][1] = (cache[i-1][2] + cache[i-1][3])%mod
  cache[i][2] = (cache[i-2][1] + cache[i-2][3])%mod
  cache[i][3] = (cache[i-3][1] + cache[i-3][2])%mod

T = int(input())

for _ in range(T):

  N = int(input())

  if N == 1:
    print(1)
  elif N == 2:
    print(1)
  elif N == 3:
    print(3)
  else:
    print(sum(cache[N])%mod)

